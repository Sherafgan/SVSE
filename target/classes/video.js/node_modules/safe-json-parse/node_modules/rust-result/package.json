{
  "name": "rust-result",
  "version": "1.0.0",
  "author": {
    "name": "Maciej Ma≈Çecki",
    "email": "me@mmalecki.com"
  },
  "description": "Mimic Rust's `std::result`",
  "main": "index",
  "homepage": "https://github.com/mmalecki/rust-result.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/mmalecki/rust-result.js.git"
  },
  "bugs": {
    "url": "https://github.com/mmalecki/rust-result.js/issues"
  },
  "scripts": {
    "test": "node test.js",
    "cover": "istanbul cover --print detail --report html test.js",
    "view-cover": "istanbul report html && opn ./coverage/index.html"
  },
  "license": "MIT",
  "devDependencies": {
    "istanbul": "^0.3.5",
    "opn": "^1.0.0",
    "tape": "^3.0.1"
  },
  "dependencies": {
    "individual": "^2.0.0"
  },
  "readme": "# rust-result.js\n\nMimic Rust's [`std::result`][result].\n\n## Installation\n\n```sh\nnpm install rust-result\n```\n\n## Usage\n\n```js\nvar fs = require('fs');\nvar Result = require('./');\n\n\n// If you want async just get a promise or something.\nvar readFile = function (path, encoding) {\n  try {\n    return Result.Ok(fs.readFileSync(path, encoding))\n  }\n  catch (ex) {\n    return Result.Err(ex)\n  }\n}\n\nvar result = readFile(__filename);\nvar v, err;\n\nif (Result.isOk(result)) {\n  v = Result.Ok(result);\n  console.log('got ' + v.length + ' bytes')\n}\nelse if (Result.isErr(result)) {\n  err = Result.Err(result);\n  console.error('oops!', err.message)\n}\n\nresult = readFile(__filename + 'I do not exist')\nif (Result.isOk(result)) {\n  v = Result.Ok(result)\n  console.log('got ' + v.length + ' bytes')\n}\nelse if (Result.isErr(result)) {\n  err = Result.Err(result)\n  console.error('oops!', err.message)\n}\n\n```\n\n## Documentation\n\n```jsig\ntype OkResult<T> : {\n  v: T\n}\ntype ErrResult<E <: Error> : {\n  err: E\n}\n\nrust-result : {\n  Ok: ((T) => OkResult<T>) |\n    ((OkResult<T>) => T) |\n    ((ErrResult<E>) => void),\n  isOk: ((OkResult<T>) => true) |\n    ((ErrResult<E>) => false)\n  Err: ((E <: Error) => ErrResult<E>) |\n    ((ErrResult<E>) => E) |\n    ((OkResult<T>) => void),\n  isErr: ((ErrResult<E>) => true) |\n    ((OkResult<T>) => false)\n}\n```\n\n### `Result.Ok`\n\nThe `Result.Ok` function is overloaded to do one of two things.\n  It can create a new `Ok` instance or it can check whether\n  the argument is an instance of `Ok`\n\nIf you call `Result.Ok` with a plain value it will return an\n  instance of `Ok` that boxes your plain value.\n\nIf you call `Result.Ok` with either an `Err` or an `Ok` instance\n  then it will return `undefined` for the `Err` and return the\n  value boxed in the `Ok`\n\n### `Result.isOk`\n\nThe `Result.isOk` function just checks whether the argument\n  is an instance of `Ok`.\n\nThis predicate function returns true if you pass it an `Ok` and\n  returns false if you pass it an `Err`\n\n### `Result.Err`\n\nThe `Result.Err` function is overloaded to do one of two things.\n  It can create a new `Err` instance or it can check whether\n  the argument is an instance of `Err`\n\nIf you call `Result.Err` with a plain error it will return an\n  instance of `Err` that boxes your plain error.\n\nIf you call `Result.Err` with either an `Err` or an `Ok` instance\n  then it will return `undefined` for the `Ok` and return the\n  value err in the `Err`\n\n### `Result.isErr`\n\nThe `Result.isErr` function just checks whether the argument\n  is an instance of `Err`.\n\nThis predicate function returns true if you pass it an `Err` and\n  returns false if you pass it an `Ok`\n\n## MIT Licenced.\n\n  [result]: http://doc.rust-lang.org/std/result/\n",
  "readmeFilename": "README.md",
  "_id": "rust-result@1.0.0",
  "dist": {
    "shasum": "6bcf5090985531a91cfd01b0b4b6bfa52666d8f6"
  },
  "_from": "rust-result@^1.0.0",
  "_resolved": "https://registry.npmjs.org/rust-result/-/rust-result-1.0.0.tgz"
}
